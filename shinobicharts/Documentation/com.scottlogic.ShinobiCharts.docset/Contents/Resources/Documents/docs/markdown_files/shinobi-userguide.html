<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>shinobi-userguide Document</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<link rel="stylesheet" type="text/css" href="../../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../../css/stylesPrint.css" />	
		<meta name="generator" content="appledoc 2.1 (build 858)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
                
				<a id="backToIndex" href="../../index.html">&lt; Back to Index</a>
				<h1><a id="libraryTitle" href="../../index.html">shinobicharts </a></h1>
				<a id="developerHome" href="http://www.shinobicontrols.com/">Scott Logic Ltd</a>
                
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode" id="pageTitleHeader">shinobi-userguide Document</h1>
			</div>
			<ul id="headerButtons" role="toolbar"></ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>













			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="shinobi-userguide Document" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../../index.html">Index</a></li>
	<li><a href="../../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">shinobi-userguide Document</h1>
					</div>
				</div>
			
				<div id="container">	
					<h1><strong>shinobicharts</strong> userguide</h1>

<h2>overview</h2>

<p>This document provides an overview of the &#83;hinobiCharts control.  It describes the features of the control and its associated concepts.</p>

<p>&#83;hinobiCharts provides a quick and effective way to visually represent data in an iOS application.  The chart contains a plot area, upon which a set of chart series (such as line, bar, OHLC, etc.) are displayed.  Each series contains a set of data points.  A chart can display a number of different types of chart series simultaneously.</p>

<p>The plot area is surrounded by axes which define the dimensions of the data specified.  Each axis has a range describing the data being displayed.  Furthermore, &#83;hinobiCharts allows the modification of the axis display by providing zoom and pan interaction out of the box.</p>

<p>If you simply want to get up and running, follow the <a href="../../docs/markdown_files/quickstart-Objective-C.html">quickstart-Objective-C</a>, or the <a href="../../docs/markdown_files/quickstart-Swift.html">quickstart-Swift</a>. Alternatively, for a more detailed description of how the chart works and the features it presents, head over to the <a href="#ControlOverview">ShinobiCharts Control Overview</a>. Finally, for guides that tackle specific usage scenarios, head on over to the <a href="#How-toGuides">ShinobiCharts How-to Guides</a>.</p>

<p>The chart has a complete set of Xamarin.iOS bindings, allowing you to make use of all of its features from within applications written in C#. In order to get up and running, follow the <a href="quickstart-Xamarin.iOS.html">quickstart-Xamarin.iOS</a>.</p>

<p><a name="ControlOverview" class="anchor offset-for-header"></a></p>

<h2><strong>shinobicharts</strong> control overview</h2>

<p>The &#83;hinobiChart provides a powerful and flexible way to represent data visually. The chart comes with a number of interactions such as pan and zoom that are optimised for touch interfaces.  The highly performant nature of the chart lends itself to the mobile environment and provides a super smooth user experience.</p>

<p>This section describes the features and concepts which constitute a chart.</p>

<p>In order to use the chart you will typically perform the following tasks:</p>

<ul>
<li>Create the <a href="../../Classes/ShinobiChart.html">ShinobiChart</a> view and add it to your view hierarchy.</li>
<li>Set the chart <code>datasource</code> property - this is used to provide data to the chart and construct appropriate chart series to display that data.</li>
<li>Set the axes on the chart. Cartesian charts must have one or more X and Y axes and radial charts must have exactly one x-axis and one y-axis.</li>
<li>(Optionally) Set the chart <code>delegate</code> property - this is used to respond to a user&rsquo;s interactions with the chart.</li>
</ul>


<p>The following sections describe this process in more detail.</p>

<h3>Anatomy of the chart</h3>

<p>There are a number of core components which make up a chart.  Here is a typical chart displaying commonly used features. Under the label of each element, is an example of a property or method that may be used to configure it. You&rsquo;ll find this type of image throughout the documentation.</p>

<p><img src="Images/userguide_anatomy1.png" width=700 alt="End result"/></p>

<p>The chart object is a <code>UIView</code> with a number of subviews to contain the visual elements. The <strong>datasource</strong> is attached to the chart and is responsible for supplying the raw data to the chart. The <strong>delegate</strong> is an optional protocol that can be adopted and attached to the chart to be notified of key events taking place. These are covered later in this document.</p>

<h3>View Structure</h3>

<p>The main chart view contains a number of subviews that each vary in size in order to accommodate the configured elements on the chart.  Below is a diagram showing the subviews and what each can contain:</p>

<p><img src="Images/userguide_anatomy2.png" width=700 alt="End result"/></p>

<p>The <strong>main chart view</strong> object is marked in green and contains all elements of the chart. This is the view that you will add to your view hierarchy when displaying a chart. The legend (also a UIView) is a part of this view, as is the title label. All other elements of the chart are contained within the canvas, marked in red. When the chart title and legend are present, the canvas must reduce in size to accommodate their placement.</p>

<p>The <strong>canvas view</strong> (<code>chart.canvas</code>) will consume as much space within the chart view as possible, whilst still allowing space for the title and legend. The canvas contains the axes and the plot area. It first places all of the axes, before working out the maximum plot area size possible.</p>

<p>The <strong>plot area</strong> is responsible for rendering all of the chart series, annotations and crosshair. It is made up of several layers including: an underlay, an openGL view, an overlay. The series are rendered on the openGL view, while the underlay and overlay are used to display annotations and grid-stripes/lines either above or below the series data.</p>

<h3>Main Visual Components</h3>

<p>Listed below are a number of the main elements making up the chart:</p>

<ul>
<li><p><strong>Chart Title</strong>: Each chart can have a single title that may be displayed at the top of the chart. <em>See <strong>Setting the Title</strong> on the <a href="../Classes/ShinobiChart.html">ShinobiChart</a> class</em></p></li>
<li><p><strong>Chart Series</strong>: The chart renders the data provided to it via one or more chart series.  These are components which determine the visual representation of the data. For example, a line series will render the data as a line chart, a column series will render it as vertical bars, and so on.  Multiple different chart series may be added to the same chart simultaneously. These are rendered in the plot area - the above image shows several line series. <em>See <a href="#The%20Series">The Series</a></em></p></li>
<li><p><strong>Axes</strong>: Many of the series types require axes (line, column, bar, etc) and some do not (pie, donut, etc). Those that require axes must have at least one X and one Y axis, but may have an arbitrary number of either, on either side of the chart. <em>See <a href="#The%20Axes">The Axes</a></em></p></li>
<li><p><strong>Legend</strong>: A chart may optionally display a legend associating a series with a title for additional information. There are several options for position and layout. <em>See <a href="#Legend">Legend</a></em></p></li>
<li><p><strong>Annotations</strong>: &#83;hinobiCharts supports additional visual cues being overlaid on the chart through the use of annotations.  These could take the form of shapes, markers, text or other visual display.  These are only supported in the premium version of &#83;hinobiCharts and display in the plot area - either above or below the data.</p></li>
<li><p><strong>Crosshair</strong>: A tooltip that tracks series values can be enabled and will display on the plot area after a long press action. <em>See <a href="#Crosshair">Crosshair</a></em></p></li>
</ul>


<p><a name = "The Datasource"></a></p>

<h3>Datasource</h3>

<p>In order to render data within the chart you need to supply that data to the chart.  The <code>datasource</code> is responsible for taking data from your data provider (simply an array or a complex web service, etc) and matching this data with the series objects that will display it on the chart.</p>

<p>You supply the object which acts as the datasource to the chart by setting the <code>datasource</code> property.  This object must adopt the <a href="../../Protocols/SChartDatasource.html"><code>SChartDatasource</code></a> protocol and respond to the minimum set of required methods.</p>

<blockquote><p><strong>Note:</strong> The chart only holds a weak reference to the <code>datasource</code> object. You must manage this object yourself.</p></blockquote>

<p>The required methods that must be implemented are as follows (note that each series and datapoint is referenced by an index just like UITableView):</p>

<ul>
<li><strong>numberOfSeriesInSChart</strong> This informs the chart of how many series it will be displaying.</li>
<li><strong>sChart:seriesAtIndex:</strong> The datasource links the data you provide to a series type. Return the series type here.</li>
<li><strong>sChart:numberOfDataPointsForSeriesAtIndex:</strong> The different series in a chart can each contain a different number of data points.  This returns the number of data points in the series at the specified index in the chart.</li>
<li><strong>sChart:dataPointAtIndex:forSeriesAtIndex:</strong> This returns the data point at the specified index from the specified series in the chart.</li>
</ul>


<p>The <a href="../../Protocols/SChartDatasource.html"><code>SChartDatasource</code></a> protocol also has optional methods to allow you to specify custom behavior for series in the chart, determine which series are rendered against which axes and optionally provide all the data for a series in a single array rather than point by point.  <em>See the <a href="../Protocols/SChartDatasource.html">SChartDatasource</a> class</em></p>

<p>We have already implemented a simple datasource you can use called <a href="../../Classes/SChartSimpleDatasource.html"><code>SChartSimpleDatasource</code></a>. If you choose to use this, it must be assigned to your chart&rsquo;s datasource property to take effect. You can add a series to your chart by simply creating an array of either <a href="../../Classes/SChartDataPoint.html"><code>SChartDataPoint</code></a>s or NSNumber objects that contain your data values along with a series object that must be a subclass of <a href="../../Classes/SChartSeries.html"><code>SChartSeries</code></a> (e.g. <a href="../../Classes/SChartLineSeries.html"><code>SChartLineSeries</code></a>). Use the <strong>addSeries:dataArray:</strong> to accomplish this.</p>

<p>If you pass in an array of NSNumber objects they will be automatically translated into an array of <a href="../../Classes/SChartDataPoint.html"><code>SChartDataPoint</code></a> objects using the NSNumber value &amp; its corresponding index as the X &amp; Y values depending on the <code>series</code> orientation.</p>

<p><a name = "Data Points"></a></p>

<h3>Data Points</h3>

<p>The <code>datasource</code> for the chart requires you to pass in data points that contain appropriate data for each series. &#83;hinobiCharts comes with several types of datapoint:</p>

<ul>
<li><strong><a href="../../Classes/SChartDataPoint.html">SChartDataPoint</a></strong> for simple, single value x and y values (eg: line, bar)</li>
<li><strong><a href="../../Classes/SChartRadialDataPoint.html">SChartRadialDataPoint</a></strong> to be used with pie/donut series. <strong>Note: In future releases, this class will be renamed, as these types of data points should only be used with pie/donut series, not radial ones like radar or polar series. The name of this class has been kept constant for now in order to not break the framework API.</strong></li>
<li><strong><a href="../../Classes/SChartMultiXDataPoint.html">SChartMultiXDataPoint</a></strong> for series with multiple x values for a single y value (vertical band)</li>
<li><strong><a href="../../Classes/SChartMultiYDataPoint.html">SChartMultiYDataPoint</a></strong> for series with multiple y values for a single x value (eg: OHLC, candlestick)</li>
<li><strong><a href="../../Classes/SChartBubbleDataPoint.html">SChartBubbleDataPoint</a></strong> to be used with <a href="../../Classes/SChartBubbleSeries.html">SChartBubbleSeries</a></li>
</ul>


<p>Using <a href="../../Classes/SChartDataPoint.html"><code>SChartDataPoint</code></a> is as simple as creating an instance and assigning the <code>xValue</code> and <code>yValue</code> properties. For series that are expecting multiple x or y values, you should use <a href="../../Classes/SChartMultiXDataPoint.html"><code>SChartMultiXDataPoint</code></a> or <a href="../../Classes/SChartMultiYDataPoint.html"><code>SChartMultiYDataPoint</code></a> and add data to <code>xValues</code> or <code>yValues</code> (respectively) for each key the series is expecting.  A list of the expected keys is available through the <code>xValueKeys</code> and <code>yValueKeys</code> methods on <a href="../../Classes/SChartSeries.html"><code>SChartSeries</code></a>.</p>

<p><a href="../../Classes/SChartBubbleDataPoint.html"><code>SChartBubbleDataPoint</code></a> is a special datapoint that also contains an <code>area</code> property in addition to <code>xValue</code> and <code>yValue</code>.</p>

<p>It is also possible to use your own objects as data points by conforming to the <a href="../../Protocols/SChartData.html"><code>SChartData</code></a> protocol . This is useful as existing model objects can be made to conform to the protocol and then given directly to the chart to avoid duplication of memory. The protocol ensures that you return a default x and y value.  The protocol also provides the option of returning additional x and y values based on a given key - useful for series types which require multiple data values, such as OHLC, candlestick and bubble charts.</p>

<h3>Labels</h3>

<h4>Cartesian Series</h4>

<p><a href="../../Classes/SChartDataPointLabel.html"><code>SChartDataPointLabel</code></a> labels can be added to your data points by setting the <code>showLabels</code> value of the <a href="../../Classes/SChartDataPointLabelStyle.html"><code>SChartDataPointLabelStyle</code></a> on a series. The label can then be styled and positioned using other properties on the style.</p>

<p><a name = "Spokes"></a></p>

<h4>Pie and Donut Series</h4>

<p>Spokes offer an alternative way of displaying labels on a pie or donut chart.</p>

<p><img src="Images/RadialSpokesScreenshot.png"/></p>

<p>Turning spoke labels on is as simple as enabling them in the pie or donut series' style object (a good place to do this is in the <code>sChart:seriesAtIndex:</code> chart datasource method):</p>

<pre><code>series.style.spokeStyle.showSpokes = YES;
series.selectedStyle.spokeStyle.showSpokes = YES;
</code></pre>

<p>To override the default styles as defined by the chart&rsquo;s theme, you can use properties contained within <a href="../../Classes/SChartSpokeStyle.html"><code>SChartSpokeStyle</code></a> to edit many aspects of the spokes, including:</p>

<ul>
<li>Offset of the spoke&rsquo;s anchor in relation to the slice&rsquo;s midpoint</li>
<li>Anchor circle radius and color</li>
<li>Spoke line width and color</li>
<li>The length of the spoke starting from the anchor point</li>
<li>Padding between slice&rsquo;s label and spoke</li>
<li>The visibility of the spoke</li>
</ul>


<p>Additionally, you can customize the selected style to make the spoke accompanying a selected slice alter in appearance. For example, to make a spoke&rsquo;s anchor circle blue and increase the radius of the anchor when a slice is selected:</p>

<pre><code>- (SChartSeries *)sChart:(ShinobiChart *)chart seriesAtIndex:(NSInteger)index {
SChartDonutSeries *series = [SChartDonutSeries new];
series.selectionAnimation.duration = @(0.4);

// Show spokes for default and selected slices
series.style.spokeStyle.showSpokes = YES;
series.selectedStyle.spokeStyle.showSpokes = YES;

// Deselected slice spoke styles
series.style.spokeStyle.anchorRadius = 5.0f;

// Selected slice spoke styles
series.selectedStyle.spokeStyle.anchorColor = [UIColor blueColor];
series.selectedStyle.spokeStyle.anchorRadius = 10.0f;

return series;
}
</code></pre>

<p><strong>NOTE:</strong> To alter the appearance of the slice labels, use the <code>SChartDelegate</code> method <code>sChart:alterLabel:forDatapoint:atSliceIndex:inRadialSeries:</code>. Within this method, you can tweak the properties of the <code>SChartSpokeStyle</code> object that manages the styling of an individual spoke. For example:</p>

<pre><code>- (void)sChart:(ShinobiChart *)chart alterLabel:(UILabel *)label forDatapoint:(SChartRadialDataPoint *)datapoint atSliceIndex:(NSInteger)index inRadialSeries:(SChartRadialSeries *)series {

SChartDonutSeries *donutSeries = (SChartDonutSeries *)series;
// Copy the series' base spoke style for its current state (default or selected) so we can use it as a foundation to build upon
SChartSpokeStyle *spokeStyle = [datapoint.selected ? donutSeries.selectedStyle.spokeStyle : donutSeries.style.spokeStyle copy];

NSInteger yVal = [datapoint.yValue integerValue];

if (yVal == 0) {
// Hide the spoke and the label
spokeStyle.showSpokes = NO;
label.hidden = YES;
}
else {
spokeStyle.length += yVal * yVal * 15;

if (datapoint.selected) {
spokeStyle.anchorColor = [UIColor orangeColor];
spokeStyle.anchorRadius *= 2;
}

label.textColor = [UIColor blackColor];
}

// Apply the custom style to the series
[donutSeries setSpokeStyle:spokeStyle forSliceIndex:index];
}
</code></pre>

<p>The result:</p>

<p><img src="Images/CustomSpokesScreenshot.png"/></p>

<p><a name = "The Axes"></a></p>

<h3>Axes</h3>

<p>Axes are used to control the view of the data, but not all chart types require axes. Cartesian charts require at least one x-axis (horizontal) and one y-axis (vertical) but support multiple axes, radial charts require exactly one x-axis and one y-axis, and pie/donut charts contain no axes.</p>

<p>Axes on a ShinobiChart are instances of the <code>SChartAxis</code> base class. However, you should always use one of the subclasses as they are designed for specific types of data. These are:</p>

<ul>
<li> <code>SChartCategoryAxis</code> works with discrete data points that have no linear correlation between their values (often strings).</li>
<li> <code>SChartDateTimeAxis</code> works with time-based data points that use NSDate as their axis value.</li>
<li> <code>SChartDiscontinuousDateTimeAxis</code> is a subclass of <code>SChartDateTimeAxis</code> that allows the specification of time periods to exclude <em>(Premium Edition only)</em>.</li>
<li> <code>SChartNumberAxis</code> works with numeric data points that use NSNumber as their axis value.</li>
<li> <code>SChartDiscontinuousNumberAxis</code> is a subclass of <code>SChartNumberAxis</code> that allows the specification of number ranges to exclude. <em>(Premium Edition only)</em></li>
<li> <code>SChartLogarithmicAxis</code> a subclass of <code>SChartNumberAxis</code> that shows numeric values on a logarithmic scale <em>(Premium Edition only)</em>.</li>
</ul>


<p>When you create a chart you should specify the primary x-axis and primary y-axis.  The following code demonstrates setting the axis types for number based data:</p>

<pre><code>chart.xAxis = [SChartNumberAxis new];
chart.yAxis = [SChartNumberAxis new];
</code></pre>

<p>As the axes are rendered, the chart will assign enough room to visually accommodate them  at their current range. This will vary depending upon the length of the tick lines and the labels, etc. As the axis range changes, the width of the axis may also vary as the tickmarks labels change length to accommodate different values. Set the <code>width</code> property on the axis to assign a fixed width of your choosing.</p>

<blockquote><p>Setting a fixed width for the axis can be useful when aligning the axes of several adjacent charts.</p></blockquote>

<p>By default, the axes will remain positioned on the border of the plot area regardless of current ranges. However, it is possible to set the point of intersection between two axes using the <code>axisPositionValue</code>. The following code would set the primary x-axis to always intersect the value 0 on the y-axis. The x-axis will move over the plot area to keep the point of intersection at 0. If 0 is outside of the current y-axis range the x-axis will be pinned at the top or bottom of the plot area.</p>

<pre><code>chart.xAxis.axisPositionValue = @0;
</code></pre>

<p>As the axis moves across the chart, the labels and tickmarks may obstruct the view of the series. Setting the <code>axisLabelsAreFixed</code> property will fix the labels and tickmarks on edge of the plot area.</p>

<p>The axes can have a <em>title</em> which is a label positioned adjacent to the axis. To set the title text simply use the <code>title</code> string property. You can style the title via the axis <code>style</code> property, or, you can make changes to the label element directly via the <code>titleLabel</code> property.</p>

<h4>Data Ranges</h4>

<p>There are several &ldquo;ranges of data&rdquo; associated with a chart axis at any one time.</p>

<ul>
<li><code>axisRange</code>: the current range displayed on the axis. This will be changed by panning and zooming actions or programmatic range changes.</li>
<li><code>dataRange</code>: the absolute minimum and maximum values across all data series represented by this axis.</li>
<li><code>visibleRange</code>: the range required to fully display all series that are not set as <code>hidden</code>. This range takes into account extra space required to fit bars or columns in, etc. It does not include any axis range padding - see <code>defaultRange</code>.</li>
<li><code>defaultRange</code>: the range displayed after initial load or when zoom is reset. Set to the <code>visibleRange + any range padding</code> by default but can also be explicitly set when initializing the axis.</li>
</ul>


<p>The ranges represent a minimum and maximum value, with <code>SChartNumberAxis</code> and <code>SChartDateTimeAxis</code> each having their own range type: <code>SChartNumberRange</code> and <code>SChartDateRange</code> respectively. <code>SChartCategoryAxis</code> uses <code>SChartNumberRange</code> where the range is applied to the integer indexes of the list of categories.</p>

<p>By default, an axis will fully display all of the non-hidden series when it initially renders. You should set your own default range if you would like a different initial range:</p>

<pre><code>SChartNumberRange *range = [[SChartNumberRange alloc] initWithMinimum:@0 andMaximum:@100];
chart.xAxis = [[SChartNumberAxis alloc] initWithRange:range];
</code></pre>

<p>Once the chart has rendered, you should make any changes to the current visible range (<code>axisRange</code>) using the following method (there are several variants):</p>

<pre><code>[chart.xAxis setRangeWithMinimum:@10 andMaximum:@40];
</code></pre>

<blockquote><p>A category axis will accept a non-integer number range to allow precise adjustments to the displayed data.</p></blockquote>

<p>It may not be desirable for the axis to initially render the visible range absolutely, you may wish for a larger range to provide more space around your data points. You should set the <code>rangePaddingHigh</code> and <code>rangePaddingLow</code> properties to add a fixed margin at each end of the visible range. This will result in the default range being <code>visibleRange + rangepadding</code>.</p>

<p>During a reload of the data or a redraw of the chart, the axis ranges will be recalculated and the default applied at render time. This may not be the desired behavior if you&rsquo;re simply making an incremental update. Set the <code>chart.autoCalculateAxisRanges</code> property to <code>NO</code> to preserve ranges.</p>

<p>It&rsquo;s possible to restrict any panning and zooming operations to defined limits. <em>See <a href="#Zooming%20and%20Panning">Zooming and Panning</a> for more details</em>.</p>

<h4>Rendering Data</h4>

<p>The axes are responsible for mapping the data values you provide into pixel values for display on the device screen. It is sometimes useful to make use of this mapping for adding additional elements to the chart. We highly recommend using our Annotation feature (see <a href="#Annotations">Annotations</a>) for this, as it fully supports the panning and zooming features. However, the <code>pixelValueForDataValue:</code> and <code>dataValueForPixelValue</code> methods support the conversion between data and pixel value and are useful when working with gesture recognizers.</p>

<p>The axes must also know how to present a raw data value for display on the chart as a tickmark or in the crosshair. The method <code>stringForId:</code> will take a data object and convert it into a string using the appropriate formatters. This method is useful when subclassing to have definitive control over the conversion of data to string. <em>See <a href="#Tickmarks">Tickmarks</a> for more information on formatters</em></p>

<h4>Multiple Axes</h4>

<p>Whilst the chart must have a minimum of one x-axis and one y-axis, there is no maximum limit when displaying cartesian series types. Additional x-axes can be added along the bottom (default) or top of the plot area. Y-axes can be added on the left (default) or right edge of the plot area. If an axis already exists in this location, the chart will stack the axes with the first axis innermost and the last axis outermost. Below is an example of multiple y-axes:</p>

<p><img src="Images/userguide_multipleAxes.png" width=900 alt="An example of multiple axes"/></p>

<p>The <em>primary</em> x-axis and y-axis are <code>chart.xAxis</code> and <code>chart.yAxis</code> respectively. Any additional axes can be found in <code>[chart allXAxes]</code> and <code>[chart allYAxes]</code>.</p>

<p>Add an additional y-axis on the right side of the chart as follows:</p>

<pre><code>SChartNumberAxis *rightY = [SChartNumberAxis new];
rightY.axisPosition = SChartAxisPositionReverse; //use the non-default position
[self.chart addYAxis:rightY];
</code></pre>

<p>After you have added an additional axis, you will want to assign a particular series to it (the default assignment for a series is the primary axis). Use the <code>sChart:xAxisForSeriesAtIndex:</code> and <code>sChart:yAxisForSeriesAtIndex:</code> methods on the datasource to return the reference to the axis for the series. It is important to return the reference of an existing axis object,  the <code>allXAxes</code> and <code>allYAxes</code> array properties on the chart provide these:</p>

<pre><code>- (SChartAxis*)sChart:(ShinobiChart*)chart xAxisForSeriesAtIndex:(NSInteger)index {
    return [chart.allXAxes objectAtIndex:0];
}
</code></pre>

<h3>Tickmarks</h3>

<p>The chart axis can display a set of tick marks and their labels that show the current range of data.  There are two levels of tickmark: major and minor; both can be auto-calculated.</p>

<p>To configure the display and style of tickmarks on the chart, use the properties on the axis style object (<code>axis.style.majorTickStyle</code>) - this includes choosing the orientation of the tick labels. The following code, for example, will hide the tick lines for all major tickmarks:</p>

<pre><code>axis.style.majorTickStyle.showTicks = NO;
</code></pre>

<p>To prevent auto-calculation and provide your own frequencies for the tickmarks, set the following properties:  <code>majorTickFrequency</code> and <code>minorTickFrequency</code> on the appropriate axis.  If <code>majorTickFrequency</code> is set the chart will only display a major tick mark at this frequency, regardless of zoom level.  The same pattern is followed for minor tick marks if <code>minorTickFrequency</code> is set.</p>

<p>Once the <code>majorTickFrequency</code> has been set or auto-calculated, tickmarks with regular spacing will be generated and by default  will start with the minimum value of <code>dataRange</code>. You can set the <code>anchorPoint</code> property to change the start point for the tickmark calculations. For example, a frequency of 2 with an anchor point of 1 will result in tickmarks at -3,-1,1,3,5,7 etc.</p>

<p>If you have a particular set of tickmarks for the axis, rather than a frequency, you should use the following delegate method to return a set of major tickmark values:</p>

<pre><code>- (NSArray *)sChart:(ShinobiChart*)chart majorTickValuesForAxis:(SChartAxis *)axis;
</code></pre>

<p>Once the values of the tickmarks have been established they must be formatted to appear as strings on the chart. Each axis has a <code>labelFormatter</code> property that will convert the tickmark value to a string. For numeric axes, you can retrieve the NSNumberFormatter:</p>

<pre><code>NSNumberFormatter *nf = axis.labelFormatter.numberFormatter;
</code></pre>

<p>For date based axes, use <code>axis.labelFormatter.dateFormatter</code> to configure the NSDateFormatter. Labels will be generated according to the conditions set on the formatter.</p>

<p>It is possible to take advantage of all of the tickmark configuration and calculations performed by the chart, but still customize individual tickmarks. You should update the tickmark object provided by the following delegate method just before it is added to the chart (<em>See <a href="../Classes/SChartTickMark.html">SChartTickMark</a> class</em>):</p>

<pre><code>-(void)sChart:(ShinobiChart *)chart alterTickMark:(SChartTickMark *)tickMark beforeAddingToAxis:(SChartAxis *)axis;
</code></pre>

<p>The <code>SChartTickMark</code> class contains the view for the tick mark, and the label for the tick mark. For example, to change the label background colour you would use the following code:</p>

<pre><code>[tickMark.tickLabel setBackgroundColor:[UIColor redColor]];
</code></pre>

<p>A suitable clipping behavior near to each edge of the axis views can be configured. The <code>tickLabelClippingModeHigh</code> and <code>tickLabelClippingModeLow</code> properties control how the tickmarks appear and disappear at the edge of the axis range, which will change during pan and zoom operations.</p>

<h4>Multiple Axes</h4>

<p>Whilst a cartesian chart must have a minimum of one x-axis and one y-axis, there is no maximum limit. Additional x-axes can be added along the bottom (default) or top of the plot area. y-axes can be added on the left (default) or right edge of the plot area. If an axis already exists in this location, the chart will stack the axes with the first axis innermost and the last axis outermost.</p>

<p>Add an additional y-axis on the right side of the chart as follows:</p>

<pre><code>SChartNumberAxis *rightY = [SChartNumberAxis new];
rightY.axisPosition = SChartAxisPositionReverse;
[self.chart addYAxis:rightY];
</code></pre>

<p>After you have added an additional axis, you will want to assign a particular series to it (the default assignment for a series is the primary axis). Use the <code>sChart:xAxisForSeriesAtIndex:</code> and <code>sChart:yAxisForSeriesAtIndex:</code> methods on the datasource to return the reference to the axis for the series. It is important to return the reference of an existing axis object,  the <code>allXAxes</code> and <code>allYAxes</code> array properties on the chart provide these:</p>

<pre><code>- (SChartAxis*)sChart:(ShinobiChart*)chart xAxisForSeriesAtIndex:(NSInteger)index {
    return [chart.allXAxes objectAtIndex:0];
}
</code></pre>

<h3>Zooming and Panning</h3>

<p>The current range of each axis defines a window of data on the chart. This window can grow smaller or larger using <em>zoom</em> operations or translated using <em>pan</em> operations. A pinch gesture on the plot area will result in a <em>zoom</em> and a drag gesture a <em>pan</em>. Gestures can be combined, just like they are on popular mapping kits, to produce combinations of pans and zooms. &#83;hinobiCharts comes fully equipped with a comprehensive set of gestures for manipulating axis ranges.</p>

<p>Panning and zooming is enabled on a per axis basis, allowing full control over the <em>window</em> view of the data. The following code enables both panning and zooming for an x-axis:</p>

<pre><code>chart.xAxis.enableGestureZooming = YES;
chart.xAxis.enableGesturePanning = YES;
</code></pre>

<p>The aspect ratio for the chart as a whole can be fixed, by default the axes support individual range changes. However, the ratio will be locked at the point of initial render by setting:</p>

<pre><code>chart.gesturePinchAspectLock = YES;
</code></pre>

<p> To give the pan and zoom gestures a more natural feel, you should enable the momentum effect. This will trigger a <em>deceleration</em> at the end of any one or combination of gestures:</p>

<pre><code>chart.xAxis.enableMomentumPanning = YES;
chart.xAxis.enableMomentumZooming = YES;
</code></pre>

<p>There is a third gesture type that affects the current axis range, <code>gestureDoubleTapResetsZoom</code>. When set to <code>YES</code>, a double tap gesture will reset the axis ranges to the <code>defaultRange</code> (_See <a href="#The%20Axes">The Axes</a> for a description of the ranges). Setting this feature to <code>NO</code> will cause a double tap gesture on the plot area to zoom an arbitrary amount in the direction of the tap. This effect is very similar to the behaviour of a map kit and is the default.</p>

<p>The last gesture type that can be used to control the current view of the chart plot area is the <em>box zoom</em>. A touch and drag with one or two fingers will superimpose a box on the plot area. As soon as the gesture is complete (the fingers are lifted clear) the chart will attempt to zoom and pan the plot area to cover the same area as the box. We recommend that the double tap gesture be configured to <em>reset the zoom level</em> when using the box gesture.</p>

<p>There are a large number of methods provided by the chart delegate that will notify you before, during and after pan and zoom operations. You should use these methods to manage any fixed zoom or pan limits where the axis properties <code>allowPanningOutOfDefaultRange</code> and <code>allowPanningOutOfMaxRange</code> don&rsquo;t off the specific level of control you need. For example, use the <code>sChartIsZooming:</code> method to monitor the relevant <code>axisRange</code> and restrict it to a minimum/maximum range.</p>

<p>The delegate methods are also very useful for synching the ranges of multiple charts. Use the <code>isPanning</code> and <code>isZooming</code> methods to set the <code>axisRange</code> on other charts you&rsquo;d like to keep in sync.</p>

<blockquote><p><strong>Note:</strong> Radial series do not currently support panning or zooming.</p></blockquote>

<h4>Disabling the Gestures</h4>

<p>There are times, such as embedding charts in a scroll view, when you will not want the chart to consume certain gestures. In &#83;hinobiCharts, a chart gesture recognizer will be disabled when the current configuration means it is no longer needed.</p>

<p>However, you can access the gesture recognisers directly on the <code>overlay</code> of the plot area. The array of recognizers can accessd at <code>chart.canvas.overlay.gestureRecognizers</code>. However, this is an series feature and you need to import <code></code>SChartCanvas<code>.h</code> and <code>SChartCanvasOverlay.h</code>.</p>

<h4>Panning a Pie/Donut Chart</h4>

<p>Whilst the pie and donut charts don&rsquo;t have axes, they do support a <em>pan</em> gesture. Individual pie and donut series can be set to allow rotation around their centre point through the <code>gesturePanningEnabled</code> property on each series. There are two key properties that support panning:</p>

<ul>
<li>use <code>rotationFriction</code> to control the momentum after a pan</li>
<li>set <code>selectionEnabledDuringPanning</code> off to allow the user to <em>stop</em> the pan momentum without any selection animations triggering</li>
</ul>


<p>The delegate provides the expected set of methods to respond to these pan events, however, there are several key properties and methods on the series that are useful tools. The current rotation of the series (from the original origin) is available through the <code>rotation</code> property. Use the method <code>rotateSliceAtIndex:toAngle:withAnimation:</code> to change the rotation of the pie or donut series. The <code>indexOfSliceAtAngle:</code> method should be used when you are detecting the current slice at a particular angle, recommended if you are using an indicator such as a needle to highlight slices.</p>

<h4>Panning and Zooming Programatically</h4>

<p>The fundamental effect of pan and zoom operations is a range change on one or more axes. Therefore, you should use one of the <code>setRangeâ€¦</code> method variants on the axes to set the ranges to achieve the desired effect.</p>

<p>Quickly panning to a set location can be achieved using the <code>panTo:</code> method on the axis, where there are options to jump to the start, end or center of the <code>visibleRange</code>. Zooming by a relative amount, such as half of or double the current range, should be accomplished using the <code>setZoomLevel:</code> method.</p>

<p><a name = "The Chart's Series"></a></p>

<h3>Series</h3>

<p>The series on a chart define how the data should be visually represented on the plot area of the chart. You will have one or more series displayed on the chart at one time; all of which will be a subclass of <a href="../../Classes/SChartSeries.html"><code>SChartSeries</code></a>.</p>

<p>Series fall into a number of groups based mainly on the coordinate space they occupy. The first grouping is <em>mapped</em> and <em>not-mapped</em>, where series that require one or more axes (lines, bars, etc) are differentiated from those that do not need any axes (pie, donut). The next grouping is a subgroup of mapped series types, <em>cartesian</em> series are those that use an x, coordinate space to plot data (line, bar, candlestick, etc). An example of a mapped series that does not is <a href="../../Classes/SChartRadialLineSeries.html"><code>SChartRadialLineSeries</code></a> which uses angle and magnitude.</p>

<p><strong>Pie</strong> and <strong>Donut</strong> series are special cases. Their data points only have an angle and they have a fixed radius. The <code>xValue</code> of a datapoint given to a Pie/Donut Series is used as the name of the slice, and the yValue is used as its magnitude (converted to an angle in relation to the other data in the same series).</p>

<h4>Series Types</h4>

<p>There are many series types available. These are that classes that you will use in your chart <code>datasource</code>:</p>

<ul>
<li><a href="../../Classes/SChartLineSeries.html"><code>SChartLineSeries</code></a> draws data points and connects them, in the order given, using a line.  The display of individual points may be enabled or disabled as required.  Similarly the area fill under the line may be enabled or disabled as required to form <strong>area series</strong>.</li>
</ul>


<p><img src="Images/userguide_lineSeries.png" width=300 alt="Line/Area Series" /></p>

<ul>
<li><code>SChartScatterSeries</code> draws data points independently on the chart, with no connections.</li>
</ul>


<p><img src="Images/userguide_scatterSeries.png" width=300 alt="Scatter Series" /></p>

<ul>
<li><a href="../../Classes/SChartBubbleSeries.html"><code>SChartBubbleSeries</code></a> draws bubbles that are placed at the x and y values of the data. A third property, <strong>Area</strong>, controls the magnitude of the bubble at each point. <em>Use <code>SChartBubbleDataPoint</code> for this series.</em></li>
</ul>


<p><img src="Images/userguide_bubbleSeries.png" width=300 alt="Bubble Series" /></p>

<ul>
<li><code>SChartColumnSeries</code> draws data points as vertical columns on the chart.</li>
</ul>


<p><img src="Images/userguide_columnSeries.png" width=300 alt="Column Series" /></p>

<ul>
<li><a href="../../Classes/SChartBarSeries.html"><code>SChartBarSeries</code></a> draws data points as horizontal bars on the chart.</li>
</ul>


<p><img src="Images/userguide_barSeries.png" width=200 alt="Bar Series" /></p>

<ul>
<li><code>SChartBandSeries</code> draws two lines (high and low) and can shade the area between them. <strong><em>(Premium Edition only)</em></strong>.</li>
</ul>


<p><img src="Images/userguide_bandSeries.png" width=300 alt="Band Series" /></p>

<ul>
<li><code>SChartCandleStickSeries</code> draws candlestick data points <strong><em>(Premium Edition only)</em></strong>.</li>
</ul>


<p><img src="Images/userguide_candlestickSeries.png" width=300 alt="CandleStick Series" /></p>

<ul>
<li><code>SChartOHLCSeries</code> draws Open High Low Close data points <strong><em>(Premium Edition only)</em></strong>.</li>
</ul>


<p><img src="Images/userguide_ohlcSeries.png" width=300 alt="OHLC Series" /></p>

<ul>
<li><a href="../../Classes/SChartStepLineSeries.html"><code>SChartStepLineSeries</code></a> draws a line chart where the connecting line will only travel in a vertical or horizontal direction to connect the data points.</li>
</ul>


<p><img src="Images/userguide_steplineSeries.png" width=300 alt="Step Line Series" /></p>

<ul>
<li><code>SChartRadialLineSeries</code> draws a line chart with polar coordinates, and connects the points in the order given, using a line.</li>
</ul>


<p><img src="Images/userguide_radialLineSeries.png" width=200 alt="Radial Line Series" /></p>

<ul>
<li><a href="../../Classes/SChartPieSeries.html"><code>SChartPieSeries</code></a> draws data points as pie slices around a central point.</li>
</ul>


<p><img src="Images/userguide_pieSeries.png" width=200 alt="Pie Series" /></p>

<ul>
<li><code>SChartDonutSeries</code> draws data points as donut slices around a central point.</li>
</ul>


<p><img src="Images/userguide_donutSeries.png" width=200 alt="Donut Series" /></p>

<h4>Passing data to a series</h4>

<p>Most of the series will only require a single <code>xValue</code> and a single <code>yValue</code> for each data point to render. For these data points you should use <a href="../../Classes/SChartDataPoint.html"><code>SChartDataPoint</code></a> or provide your own implementation conforming to  the <a href="../../Protocols/SChartData.html"><code>SChartData</code></a> protocol. The chart will only use <code>xValue</code> and <code>yValue</code> when loading data.</p>

<p><a href="../../Classes/SChartBandSeries.html"><code>SChartBandSeries</code></a>, <a href="../../Classes/SChartCandlestickSeries.html"><code>SChartCandlestickSeries</code></a> and <a href="../../Classes/SChartOHLCSeries.html"><code>SChartOHLCSeries</code></a> require multiple values on one axis to render. For these series types you should use <a href="../../Classes/SChartMultiXDataPoint.html"><code>SChartMultiXDataPoint</code></a> or <a href="../../Classes/SChartMultiYDataPoint.html"><code>SChartMultiYDataPoint</code></a>. These require you to add data to the <code>xValues</code> or <code>yValues</code> dictionaries respectively. The keys that the chart will expect for a particular series are available on the series using the <code>xValueKeys</code> and <code>yValuekeys</code> respectively.</p>

<pre><code>[dataPoint.yValues setObject:closePrice forKey:SChartCandlestickKeyClose];
</code></pre>

<p><em><code>SChartBubbleSeries</code> has its own data point class, <code>SChartBubbleDatapoint</code>, which should be used for this series type.</em></p>

<p><a href="../../Classes/SChartLineSeries.html"><code>SChartLineSeries</code></a> supports &lsquo;discontinuous&rsquo; data series, which allow gaps in the line series. To insert a gap between two points, you can supply a point with a nil y-value at an x-value between those points. Note for a vertical line series (where the orientation property is <code>SChartSeriesOrientationVertical</code>), the reverse applies: provide a nil x-value for a y-value between two points to insert a gap.</p>

<h4>Styling the series</h4>

<p>The series dictate how the data will be rendered on chart plot area. The <em>type</em> of series defines the structure of the series - but the style properties define the look. Each series has a <code>style</code> and <code>selectedStyle</code> property that contains all of the settings used to control the look of the series when rendered. The <code>style</code> property is used when the series is not selected and the <code>selectedStyle</code> is used when the series has been selected.</p>

<p>For example, the following code will set the line color and thickness for a <a href="../../Classes/SChartLineSeries.html"><code>SChartLineSeries</code></a> when it is not selected:</p>

<pre><code> lineSeries.style.lineColor = [UIColor redColor];
 lineSeries.style.lineWidth = @2;
</code></pre>

<h4>Curved Bars &amp; Columns</h4>

<p>We have a <code>cornerRatio</code> property on our <a href="../../Classes/SChartBarColumnSeriesStyle.html"><code>SChartBarColumnSeriesStyle</code></a> that controls how curved the tips of each bar &amp; column are by applying a corner radius to the tip&rsquo;s corners. The corner radius is calculated by multiplying the <code>cornerRatio</code> value with half the bar or columns width. You can only set the <code>cornerRatio</code> property to a value between 0 and 1.</p>

<p>For example, the following code will set the corner ratio for a <a href="../../Classes/SChartColumnSeries.html"><code>SChartColumnSeries</code></a> to 1 to show fully curved columns:</p>

<pre><code>columnSeries.style.cornerRatio = 1;
</code></pre>

<h4>Stacking series</h4>

<p>By default, series are independent of each other and will render without any regard for the other series on the plot area. However, if you desire certain series to be grouped together and their values to be summed cumulatively you should set their <code>stackIndex</code> property to be the same value.</p>

<p><img src="Images/userguide_stackedSeries.png" width=200 alt="Stacked Series" /></p>

<p>The actual value of <code>stackIndex</code> is not important, series with the same stackIndex value will be grouped into <em>stacks</em> with the first series (lowest series index in datasource) at the bottom. Using multiple <code>stackIndex</code> values will result in multiple groupings of series and therefore multiple stacks of data</p>

<blockquote><p><strong>Note:</strong> Series in the same stack must have <strong>all positive</strong> or <strong>all negative</strong> values and be ordered to produce reliable stacked data</p>

<p><strong>Note:</strong> Radial and pie/donut series do not currently support stacking.</p></blockquote>

<h4>Selection</h4>

<p>Series can be switched to a <em>selected</em> state that will trigger a change in appearance using the <code>selectedStyle</code> and use the delegate to notify of this change. Selection is triggered by a single touch event on the plot area with the nearest series being selected or de-selected.</p>

<p><img src="Images/userguide_selectedSeries.png" width=250 alt="Selected Series" /></p>

<p>You should set the <code>selectionMode</code> property to one of <em>none</em>, <em>series</em> or <em>point</em>. <em>Series</em> selection will ensure that the whole series will be selected, whereas <em>point</em> mode will only set the nearest point as selected. If the intention is for only a single series to be in the selected state at any one time, you should ensure that the <code>toggleSelection</code> and <code>togglePointSelection</code> properties are set to <code>YES</code>.</p>

<p>If you have a delegate, it will be notified of any selection events.</p>

<blockquote><p><strong>Note:</strong> Bar, Column, Candlestick and OHLC series do not support individual point styling - therefore, whilst a selection event will be triggered for a particular point, individual point styling will have no effect.</p></blockquote>

<p>Pie and Donut series have additional properties pertaining to selection events. Upon selection the Pie or Donut can rotate the selected slice to a particular angle given by the <code>selectedPosition</code> property (radians). The rotation can also be animated, the <code>selectionAnimation</code> property should be used to control this animation.</p>

<h4>Legend entries</h4>

<p>If the <code>showInLegend</code> property is set to <code>YES</code>, the series will display in the legend. The <code>title</code> property should be used to control the text description of the series in the legend. The <a href="../../Classes/SChartSeries.html"><code>SChartSeries</code></a> class conforms to the <a href="../../Protocols/SChartLegendItem.html"><code>SChartLegendItem</code></a> protocol. You should subclass the relevant series class to modify standard behaviour and customize legend appearance.</p>

<pre><code>series.showInLegend = YES;
series.title = @"Carrots";
</code></pre>

<h4>Animation</h4>

<p>The display of series is controlled by the <code>hidden</code> property. Set this property to <code>NO</code> initially if you want to show the series at a later point. When a series is initially rendered, or <code>hidden</code> is set to <code>YES</code> after being <code>NO, the</code><a href="../../Classes/SChartAnimation.html">SChartAnimation</a><code>assigned to the</code>entryAnimation<code>property will be used to animate the series onto the plot area during the next redraw. The</code>exitAnimation` is used to remove the series from the plot area.</p>

<p>Animation effects should be enabled for the series using the <code>animationEnabled</code> property.</p>

<blockquote><p><strong>Note:</strong> Radial series do not currently support animation.</p></blockquote>

<p><a name = "Legend"></a></p>

<h3>Legend</h3>

<p>The chart&rsquo;s legend is a view that displays a representation of the series on the chart (series can be configured not to appear in the legend - _see <code>showInLegend</code> property on <a href="../Classes/SChartSeries.html"><code>SChartSeries</code></a>).</p>

<p><img src="Images/userguide_legend.png" width=300 alt="Legend" /></p>

<p>By default, an <code>SChartLegend</code> object is created and assigned to <code>chart.legend</code> but is hidden from view. To make the legend appear, set the <code>hidden</code> property:</p>

<pre><code>chart.legend.hidden = NO;
</code></pre>

<p>The legend can be rendered in a number of locations on the chart using the <code>position</code> property. The <code>position</code> can be relative to either the plot area or the chart by setting the <code>placement</code> property.</p>

<blockquote><p>For Pie and Donut charts, an entry for each slice (data point) rather than each series is added to the legend. Only the first series is displayed</p></blockquote>

<p><a name = "Crosshair"></a></p>

<h3>Crosshair</h3>

<p>The crosshair on the chart is used to identify specific values on chart series using a small target and tooltip. It is enabled using a long press gesture on the plot area and will track the nearest series for which tracking is enabled.</p>

<p><img src="Images/api_crosshair.png" width=350 alt="Crosshair" /></p>

<p>The crosshair is enabled <em>per series</em> using the following property, and will only interact with enabled series:</p>

<pre><code>series.crosshairEnabled = YES;
</code></pre>

<p>The <code>SChartCrosshair</code> provides a small circle target with lines that extend to the axis and is enabled with a tap-and-hold gesture. The crosshair will appear on the nearest series and will remain on this series during drag gestures if the <code>mode</code> property is set to <code>SChartCrosshairModeSingleSeries</code>; otherwise it will track the nearest point on any enabled series. The crosshair will snap to data points if the <code>interpolatePoints</code> property is set to <code>NO</code>. If set to <code>YES</code> the crosshair will move smoothly between points when tracking a line series.</p>

<p>The drawing of the lines and target circle is performed in the method <code>drawCrosshairLines</code>; you should subclass <code>SChartCrosshair</code> and replace this method to customize the drawing of these elements. Replace the <code>chart.crosshair</code> instance with your own subclass instance.</p>

<p>The most common customization of the crosshair is the tooltip that accompanies the lines and target circle. The tooltip (<code>SChartCrosshairTooltip</code>) displays the information about the data point. Modify the existing instance at <code>crosshair.tooltip</code> or assign an instance of your own subclass.</p>

<blockquote><p><strong>Note:</strong> Radial and pie/donut series do not currently support crosshairs.</p></blockquote>

<p><a name = "Series-Crosshair"></a></p>

<h3>Series Crosshair</h3>

<p>The Series Crosshair features a new tooltip with a caret pointing in the direction of the currently tracked datapoint.</p>

<p><img src="Images/crosshair_series.png" width=350 alt="Series Crosshair" /></p>

<p>To enable the Series Crosshair:</p>

<pre><code>_chart.crosshair = [[SChartSeriesCrosshair alloc] init];
</code></pre>

<blockquote><p><strong>Note:</strong> As in the above section, for the Series Crosshair to track a series, the series must have its <code>crosshairEnabled</code> property set to <code>YES</code>.</p></blockquote>

<p>Default configuration:</p>

<ul>
<li><p>Color is extracted from the series the crosshair is currently tracking and applied as its background color. <code>SChartSeriesCrosshairTooltipStylerProtocol</code> is responsible for extracting attributes from the series and <code>SChartCrosshairStyle</code> which are then applied to the Series Crosshairâ€™s tooltip.</p></li>
<li><p>Positioned above or below the datapoint and offset from the datapoint by 20 points. Positioning is handled by an object that conforms to <code>SChartSeriesCrosshairTooltipPositionerProtocol</code>.</p></li>
<li><p>Tooltip drawn with caret pointing towards datapoint. Caret size can be altered using the tooltipâ€™s <code>caretWidth</code> property. Drawing is handled by an object that conforms to <code>SChartSeriesCrosshairTooltipDrawerProtocol</code>.</p></li>
</ul>


<blockquote><p><strong>Note:</strong> All <code>SChartSeries</code> have the above defaults except <code>SChartBarSeries</code>, where the tooltip is positioned to the left or right of the datapoint.</p></blockquote>

<p><a name = "The Delegate"></a></p>

<h3>Delegate</h3>

<p>The chart reports actions and events to the optionally assigned delegate. All of the methods are optional, with a full list available on the <a href="../Protocols/SChartDelegate.html"><code>SChartDelegate</code></a> protocol. Common interactions reported include:</p>

<ul>
<li>Zooming.</li>
<li>Panning.</li>
<li>Touch events.</li>
<li>Crosshair tracking.</li>
<li>Rendering of data in the chart.</li>
<li>Chart series animation.</li>
<li>Data loading.</li>
</ul>


<h4>Common use cases</h4>

<ul>
<li><code>sChartWillStartLoadingData:</code> This is called before the chart starts loading its data from its datasource.  At this point, the chart has been created, but it either doesn&rsquo;t contain any data, or it is about to reload its data.  You shouldn&rsquo;t do anything with chart axes at this point, as they will be out of date with the new data.  A common use case for this method would be to pop up an activity indicator if you think the data will take a long time to load.</li>
<li><code>sChartDidFinishLoadingData:</code> This is called once the chart has finished loading its data, and before it starts rendering its plot area and axes.  A common use of this method would be to close the activity indicator if you popped one up during loading.  At this point, the chart axes will have been refreshed from the new data, so you could update the chart axes here before they are rendered.  It is important to note that this method is only called when we load data, rather than each time the chart is rendered.</li>
<li><code>sChartRenderStarted:withFullRedraw:</code> This is called before the chart starts rendering its data.  At this point, the chart axes will be up to date with your data, so a common use case of this method would be to update the chart axes before they are rendered, for example to modify the axis title or range.</li>
<li><code>sChartRenderFinished:</code> This is called once the chart has finished rendering its data.  A common use case for this method would be to display the crosshair on the chart after it has rendered, or to add annotations onto the chart.  You could also update other UI elements in your application so that they reflect the new state of the chart.  You shouldn&rsquo;t modify the chart plot area or its axes here, as any changes won&rsquo;t be visualized until the next time that the chart is rendered. This event may be fired more than once due to it taking several renders to successfully layout a chart. <em>It is not a &ldquo;chartDidAppear&rdquo; method, make sure your code only executes once if required</em>.</li>
</ul>


<h3>Annotations</h3>

<p>You can add extra objects to the plot area of the chart that provide more information about the series. These are UIView based object and should be a subclass of either <code>SChartAnnotation</code> or <code>SChartAnnotation</code> zooming. (<em>See <a href="../Classes/SChartAnnotation.html"><code>SChartAnnotation</code></a> class</em>)</p>

<p>An annotation is not simply a view added to the chart, as this would remain static during panning and zooming and bear no relation to the series data. For this kind of addition, add a subview to the chart view. Annotations must be given a x-axis and a y-axis to allow the <code>xValue</code> and <code>yValue</code> properties to be mapped onto the plot area. <em>See <a href="#How%20to:%20Add%20Annotations%20to%20a%20Chart"><code>How to: Add Annotations to a Chart</code></a></em></p>

<h3>Styling a Chart</h3>

<p>The charts offer a flexible styling interface to change the look and feel of the UI elements. The following section details the key methods, which can be used interchangeably to achieve the desired effects and suit the structure of your app. The chart will always use the properties of each style object for its appearance, the following explains how they are set.</p>

<p><a name = "Themes"></a></p>

<h4>Themes</h4>

<p>When a chart first loads, it will use a theme object to define its appearance. The theme sets the style properties of each chart element to predefined values. There are three themes:</p>

<ul>
<li><code>SChartLightTheme</code> is brighter colors based on a white background</li>
<li><code>SChartDarkTheme</code> is based on softer colors on a black background</li>
<li><code>SChartiOS7Theme</code> is based on the sharp and brightly coloured style used in iOS 7</li>
</ul>


<p>By default, with no theme explicitly set, the chart will take its theme from the global <code>ShinobiCharts</code> object. This is determined by the iOS version of the device; with iOS6 (and lower) devices using the <code>SChartLightTheme</code> and iOS7+ devices using <code>SChartiOS7Theme</code>. To set a theme that all of your charts universally adopt, you should set the theme on the <code>ShinobiCharts</code> object:</p>

<pre><code>[ShinobiCharts setTheme:[SChartDarkTheme new]];
</code></pre>

<p>You should do this before any charts are created, as the chart will query this object when it is first initialized - the app delegate is a good location.</p>

<p>If you&rsquo;d like to use a different theme to style each chart, you should use the <code>applyTheme</code> method on each instance:</p>

<pre><code>[myChart applyTheme:[SChartDarkTheme new]];
</code></pre>

<p>The above code will set all of the style object properties to match those specified by the darker theme. <strong>This will override any previously set values for the style objects!</strong> Be sure to make any direct customizations of the style objects <em>after</em> you call <code>applyTheme</code>.</p>

<p><a name = "Styles"></a></p>

<h4>Styles</h4>

<p>Most UI elements on the chart have a style property that defines its look. These are set by a theme, but should be modified to achieve a custom look. <em>Calling <code>applyTheme</code> will set these properties, which means it is important to make any direct style changes <strong>after</strong> you have applied your theme.</em></p>

<p>Here is an example of setting the axis line color:</p>

<pre><code>chart.yAxis.style.lineColor = [UIColor redColor];
</code></pre>

<p>Some objects may have more than one style object. For example, a series has a <code>style</code> and a <code>selectedStyle</code>. These contain the same properties but are used in the appropriate context.</p>

<blockquote><p>Check the style classes in the API documentation for detailed descriptions of each style and it&rsquo;s properties.</p></blockquote>

<h3>Lifecycle of a Chart</h3>

<p>In this section we will describe what happens when you add a chart to your application.</p>

<p>The first time a chart renders, or if you have told the chart to reload its data, it will query the datasource for the data to draw the chart.  This involves the following steps:</p>

<ul>
<li>The chart calls <code>sChartWillStartLoadingData:</code> on its delegate.</li>
<li>The chart queries its datasource for the number of series.</li>
<li><p>The chart then queries the datasource for the data in each series.  For each series, it goes through the following steps:</p>

<ul>
<li>First it calls <code>sChart:seriesAtIndex:</code> on the datasource to get the series object.</li>
<li>Then it calls <code>sChart:numberOfDataPointsForSeriesAtIndex:</code> on the datasource to get the number of data points in the series.</li>
<li>Once the chart knows the number of data points in the series, it gets the data points from the datasource.  If the datasource provides the data points as an array, it gets this array from the datasource by calling <code>sChart:dataPointsForSeriesAtIndex:</code>.  If not, the chart loops through and calls <code>sChart:dataPointAtIndex:forSeriesAtIndex:</code> for each data point.  The chart populates the series with these data points.</li>
</ul>
</li>
</ul>


<p>Once the chart has loaded all its data from its datasource, it does the following:</p>

<ul>
<li>The chart updates its axes from the new data.</li>
<li>The chart calls <code>SChartDidFinishLoadingData:</code> on its delegate.</li>
</ul>


<p>Once the data is loaded, and the axes have been updated, the chart renders its plot area.</p>

<ul>
<li>First, it calls <code>sChartRenderStarted:withFullRedraw:</code> on its delegate.  The second argument indicates whether the chart is recalculating the layout of its elements.  The chart will perform calculations on the data if it has loaded new data or if this is the first time it is rendering.</li>
<li>The chart then uses the calculated data to render the series.</li>
<li>Once all the data has been rendered, the chart calls <code>sChartRenderFinished:</code> on its delegate.</li>
</ul>


<p><a name="How-toGuides" class="anchor offset-for-header"></a></p>

<h2><strong>shinobicharts</strong> how-to guides</h2>

<h3>How to: Render a Column Chart</h3>

<p>This how-to guide will lead you through the steps required to render a simple column chart.</p>

<p><img src="Images/ColumnChart.png"/></p>

<p>In order to render a column chart you need to do the following:</p>

<ol>
<li>Create a chart with a numeric Y axis and a category X axis</li>
<li>Implement the datasource, as follows:

<ol>
<li>Return a <code>SChartColumnSeries</code> in response to the <code>sChart:seriesAtIndex:</code> datasource method.</li>
<li>When the datasource requests a datapoint, provide a datapoint with an <code>NSString</code> for the x-value and an <code>NSNumber</code> for the y-value.</li>
</ol>
</li>
</ol>


<p>Depending on the type of data you are rendering, you have to select an appropriate axis type. Currently ShinobiChart has numeric  (both linear and logarithmic), date-time and category axis types.</p>

<p>When rendering column series, your data will most often be in the form of string &lsquo;categories&rsquo; mapped to numeric values. For example, you could use a couple of dictionaries to record the sales for various categories of product for a number of years:</p>

<pre><code>NSDictionary* _sales[2];

_sales[0] = @{@"Broccoli" : @5.65, @"Carrots" : @12.6, @"Mushrooms" : @8.4};
_sales[1] = @{@"Broccoli" : @4.35, @"Carrots" : @13.2, @"Mushrooms" : @4.6, @"Okra" : @0.6};
</code></pre>

<p>Note, that if you have multiple column series you do not have to have the same category values in each series.</p>

<p>The category axis type has a couple of properties that relate to how the columns are positioned with respect to each other:</p>

<pre><code>// add a pair of axes
SChartCategoryAxis *xAxis = [SChartCategoryAxis new];
xAxis.style.interSeriesPadding = @1.0;
_chart.xAxis = xAxis;

SChartAxis *yAxis = [SChartNumberAxis new];
yAxis.title = @"Sales (1000s)";
yAxis.rangePaddingHigh = @1.0;
_chart.yAxis = yAxis;
</code></pre>

<p>In the above code the <code>interSeriesPadding</code> is set to 1.0, so that the columns in each series touch their neighbors. You can also modify the <code>interSeriesSetPadding</code> to configure the distance between the groups of series within each category.</p>

<p>In this example the data point returned by the datasource simply returns the key-value pairs from the dictionary:</p>

<pre><code>- (id&lt;SChartData&gt;)sChart:(ShinobiChart *)chart dataPointAtIndex:(NSInteger)dataIndex forSeriesAtIndex:(NSInteger)seriesIndex {
    SChartDataPoint *datapoint = [SChartDataPoint new];
    NSString* key = _sales[seriesIndex].allKeys[dataIndex];
    datapoint.xValue = key;
    datapoint.yValue = _sales[seriesIndex][key];
    return datapoint;
}
</code></pre>

<p>See related code sample: <strong>ColumnSeries.xcodeproject</strong></p>

<h3>How to: Render a Pie or Donut Chart</h3>

<p>This how-to guide will lead you through the steps required to render a simple pie or donut chart.</p>

<p><img src="Images/PieChart.png"/></p>

<p>In order to render a pie chart you need to do the following:</p>

<ol>
<li>Create a chart without providing an explicit axis.</li>
<li>Implement the datasource, as follows:

<ol>
<li>Return a <code>SChartPieSeries</code> in response to the <code>sChart:seriesAtIndex:</code> datasource method.</li>
<li>When the datasource requests a data point, provide a <code>SChartRadialDataPoint</code> instance for each datapoint. This data point type has a <code>name</code> property which is used to provide the name for each slice, and a <code>value</code> property which provides the size of each slice.</li>
</ol>
</li>
</ol>


<p>To render pie or donut charts create an instance of the <code>ShinobiChart</code> without providing an explicit axis. The chart will determine that it is rendering data as a pie/donut from the type of the data points returned via the datasource.</p>

<p>When rendering pie charts your data will often be in the form of a dictionary that maps categories of data to their value. Here is an example of a dataset which shows the area of the six largest countries:</p>

<pre><code>NSDictionary* _countrySize;

 _countrySize = @{@"Russia" : @17, @"Canada" : @9.9, @"USA" : @9.6,
                  @"China" : @9.5, @"Brazil" : @8.5, @"Australia" : @7.6};
</code></pre>

<p>For a pie chart the datasource implementation must return a <code>SChartPieSeries</code>:</p>

<pre><code>-(SChartSeries *)sChart:(ShinobiChart *)chart seriesAtIndex:(NSInteger)index {
    SChartPieSeries* pieSeries = [SChartPieSeries new];
    return pieSeries;
}
</code></pre>

<p>And the datasource method that requests data points must return <code>SChartRadialDataPoint</code> instances:</p>

<pre><code>- (id&lt;SChartData&gt;)sChart:(ShinobiChart *)chart dataPointAtIndex:(NSInteger)dataIndex forSeriesAtIndex:(NSInteger)seriesIndex {
    SChartRadialDataPoint *datapoint = [SChartRadialDataPoint new];
    NSString* key = _countrySize.allKeys[dataIndex];
    datapoint.name = key;
    datapoint.value = _countrySize[key];
    return datapoint;
}
</code></pre>

<p>Rendering a pie chart is really that simple!</p>

<p>When creating the <code>SChartPieSeries</code> you have the opportunity to change the style and selection behaviour of the series. For example, you can modify the &lsquo;protrusion&rsquo; of the selected slices, which causes them to move out from the centre on selection. You can set the <code>selectedPosition</code> which causes the selected slice to rotate to the given angle. You can also customize the selection animation, changing its duration, or replacing it with one of the other <code>SChartAnimation</code> instances that are part of the chart API:</p>

<pre><code>-(SChartSeries *)sChart:(ShinobiChart *)chart seriesAtIndex:(NSInteger)index {
    SChartPieSeries* pieSeries = [SChartPieSeries new];
    pieSeries.selectedStyle.protrusion = 10.0f;
    pieSeries.selectionAnimation.duration = @0.4;
    pieSeries.selectedPosition = @0.0;
    return pieSeries;
}
</code></pre>

<p>There are many more ways in which you can change the style of the pie series, see the <code>SChartPieSeriesStyle</code> class for more details.</p>

<p>To determine which slice was selected, simply adopt the <code>SChartDelegate</code> protocol and implement the &lsquo;toggleSelection&rsquo; method as follows:</p>

<pre><code>- (void)sChart:(`ShinobiChart` *)chart toggledSelectionForRadialPoint:(`SChartRadialDataPoint` *)dataPoint   inSeries:(`SChartRadialSeries` *)series atPixelCoordinate:(CGPoint)pixelPoint{
    NSLog(@"Selected country: %@", dataPoint.name);
}
</code></pre>

<p>If you want to render a donut chart, which is basically a pie chart with a hole in the centre, simply change the series type from <code>SChartPieSeries</code> to <code>SChartDonutSeries</code>.</p>

<p>An alternative way of displaying labels is by using <a href="Spokes">spokes</a>.</p>

<p>See related code sample: <strong>PieChart.xcodeproject</strong></p>

<h3>How to: Render a Time Series Chart</h3>

<p>This how-to guide will lead you through the steps required to render a time series chart, i.e. a chart with a date axis.</p>

<p><img src="Images/TimeSeries.png"/></p>

<p>In order to render a time series you need to do the following:</p>

<ol>
<li>Create a chart with a numeric Y axis and a <code>SChartDateTimeAxis</code> or <code>SChartDiscontinuousDateTimeAxis</code> X axis</li>
<li>Add data points which have X values of type <code>NSDate</code> and Y values of type <code>NSNumber</code>.</li>
<li>Optionally add discontinuities to the chart that exclude weekends or holidays.</li>
</ol>


<p>The Shinobi Chart supports rendering of data against a date / time axis via either the <code>SChartDateTimeAxis</code> or <code>SChartDiscontinuousDateTimeAxis</code> axis types. Both of these expect the data points to have values of type <code>NSDate</code>. The date / time axes have special tick mark calculation logic which presents ticks as years, months, weeks, days etc â€¦ based on the current visible range.</p>

<p>Regular axes are &lsquo;continuous&rsquo;, every point between their upper and lower range values is present on the axis. A discontinuous axis is one which supports one or more &lsquo;exclusions&rsquo;, i.e. ranges of values that are omitted from the axis. This is typically used for time series in order to omit weekends or bank holidays.</p>

<p>With the <code>SChartDiscontinuousDateTimeAxis</code> you can specify time periods which you wish to exclude from the axis. These can either be a single time period, for example, a bank holiday, or a repeated time period, such as weekends, or non-working hours.</p>

<p>For example, if you wish to remove the weekends from a time series chart add the following repeated exclusion:</p>

<pre><code>// add a discontinuous date axis
SChartDiscontinuousDateTimeAxis *xAxis = [SChartDiscontinuousDateTimeAxis new];

// a time period that defines the weekends
SChartRepeatedTimePeriod* weekends = [[SChartRepeatedTimePeriod alloc] initWithStart:[self dateFromString:@"02-01-2010"]
                                                                          andLength:[SChartDateFrequency dateFrequencyWithDay:2]
                                                                       andFrequency:[SChartDateFrequency dateFrequencyWithWeek:1]];
[xAxis addExcludedRepeatedTimePeriod:weekends];
</code></pre>

<blockquote><p><strong>NOTE:</strong> The <code>SChartDiscontinuousDateTimeAxis</code> is a premium charts feature, whereas <code>SChartDateTimeAxis</code> is available in the standard edition.</p></blockquote>

<p>See related code sample: <strong>TimeSeries.xcodeproject</strong></p>

<h3>How to: Render a Candlestick Chart</h3>

<p>This how-to guide will lead you through the steps required to render a candlestick chart - this is one of a class of series types that have multiple X or Y values.</p>

<blockquote><p><strong>NOTE:</strong> Candlestick series are a premium charts feature.</p></blockquote>

<p><img src="Images/CandlestickChart.png"/></p>

<p>In order to render a candlestick series you need to do the following:</p>

<ol>
<li>Create a chart with a numeric Y axis and a numeric or date / time X axis. (NOTE: you can render candlestick series vertically or horizontally, however, horizontal is the most common configuration)</li>
<li>Add a <code>SChartCandlestickSeries</code> series to the chart via the <code>sChart:seriesAtIndex:</code> datasource method.</li>
<li>Add data points that have multiple Y values corresponding to the value keys for the candlestick series, e.g. <code>SChartCandlestickKeyOpen</code>, <code>SChartCandlestickKeyClose</code> â€¦</li>
</ol>


<p>Shinobi Charts has a number of series that expect multiple values, this includes <code>SChartBandSeries</code>, <code>SChartCandlestickSeries</code> and <code>SChartOHLCSeries</code>. When rendering a chart using one of these series types your data points must provide multiple X or Y values (depending on the chart orientation).</p>

<p>The <code>SChartData</code> protocol, which is used to describe data points, has optional methods defined that allow the chart to request data point values by name, for example <code>sChartYValueForKey:</code>. You can adopt this protocol with your own data objects, or use one of the provided implementations such as <code>SChartMultiYDataPoint</code>.</p>

<p>For example, to populate a data series from JSON data for rendering with a candlestick series, you could do the following:</p>

<pre><code>// load the JSON data into an array
NSString* filePath = [[NSBundle mainBundle] pathForResource:@"AppleStock" ofType:@"json"];
NSData* json = [NSData dataWithContentsOfFile:filePath];
NSArray* data = [NSJSONSerialization JSONObjectWithData:json
                                                options:NSJSONReadingAllowFragments
                                                  error:nil];

// iterate over the array, creating a datapoint for each value.
for (NSDictionary* jsonPoint  in data) {
    SChartMultiYDataPoint* datapoint = [SChartMultiYDataPoint new];
    datapoint.xValue = [self dateFromString:jsonPoint[@"date"]];
    NSDictionary* yValues = @{SChartCandlestickKeyOpen: jsonPoint[@"open"],
                              SChartCandlestickKeyHigh: jsonPoint[@"high"],
                              SChartCandlestickKeyLow: jsonPoint[@"low"],
                              SChartCandlestickKeyClose: jsonPoint[@"close"]};
    datapoint.yValues = [NSMutableDictionary dictionaryWithDictionary:yValues];
    [_timeSeries addObject:datapoint];
}
</code></pre>

<p>See related code sample: <strong>CandlestickChart.xcodeproject</strong></p>

<h3>How to: Render a Bubble Chart</h3>

<p>This how-to guide will lead you through the steps required in order to render a bubble chart, an x/y scatter chart where the size of each datapoint is configurable.</p>

<p><img src="Images/BubbleSeries.png"/></p>

<p>In order to render a bubble chart you need to do the following:</p>

<ol>
<li>Create a chart and assign a datasource that provides your &lsquo;bubble&rsquo; data.</li>
<li>Implement the <code>SChartDatasource</code> protocol as follows:

<ol>
<li>Return an <code>SChartBubbleSeries</code> instance in response to the <code>sChart:seriesAtIndex:</code> delegate method.</li>
<li>Return <code>SChartBubbleDataPoint</code> instances in response to the    <code>sChart:dataPointAtIndex:forSeriesAtIndex:</code> delegate method, where the <code>area</code> property value details the size of the bubble at the given x and y location.</li>
</ol>
</li>
</ol>


<p>A bubble series is a variation of the x/y scatter series where each datapoint is rendered as a &lsquo;bubble&rsquo; of varying size.</p>

<p>The rendered size of each bubble is determined by a multiplying the <code>area</code> property of the <code>SChartBubbleDataPoint</code> instance that the bubble represents with the <code>scale</code> property of the <code>SChartBubbleSeries</code>. The product of these two values determines the area (in pixels) of the rendered bubble. This means that the data you supply via your <code>SChartBubbleDataPoint</code> can be expressed in units that are independent from the size of your chart - e.g. you might create a bubble series where each bubble represents the surface area of a country.</p>

<p>Rather then explicitly supplying a scale for the bubble series, it can be easier to simply inform the series of the size you want for the largest bubble. If you set the <code>biggestBubbleDiameterForAutoScaling</code> property on the series it will compute a suitable scale based on the data you supply via the datasource.</p>

<p>See related code sample: <strong>BubbleSeries.xcodeproject</strong></p>

<h3>How to: Render a Polar Chart</h3>

<p>This how-to guide will lead you through the steps required in order to render a Polar Chart, a <strong>radial</strong> chart that is used to display <strong>continuous</strong> data along its <strong>x-axis</strong>.</p>

<p><em>A radial chart will render as a circular chart with two axes. The x-axis is rendered as a full circle around the outside of the charts circular plot area, the y-axis will render vertically upwards from the pole (the center) meeting the x-axis.</em></p>

<p><img src="Images/PolarChart.png"/></p>

<p>In order to render a Polar Chart you need to do the following:</p>

<ol>
<li>Create a chart.</li>
<li>Add an x-axis of type <code>SChartNumberAxis</code>. To render a Polar Chart you must use an axis capable of plotting continuous data, and the only such axis that is currently supported is <code>SChartNumberAxis</code>.</li>
<li><p>Add a y-axis of your choosing. (Radial Charts currently support <code>SChartNumberAxis</code> and <code>SChartCategoryAxis</code>).</p>

<pre><code>// Assign the axes.
_chart.xAxis = [SChartNumberAxis new];
_chart.yAxis = [SChartNumberAxis new];
</code></pre></li>
<li><p>Return series of type <code>SChartRadialLineSeries</code> from your datasource via the <code>sChart:seriesAtIndex:</code> method. This causes the chart to draw in a radial fashion, with your data being plotted with a line joining your datapoints.</p>

<pre><code>-(SChartSeries *)sChart:(ShinobiChart *)chart seriesAtIndex:(NSInteger)index
{
    SChartRadialLineSeries *series = [SChartRadialLineSeries new];
    return series;
}
</code></pre></li>
<li><p>Return <code>SChartDatapoint</code> objects from your datasource, populating the <code>xValue</code> and <code>yValue</code> properies. The <code>xValue</code> corresponds to the angle around the pole that the datapoint will be drawn at. The <code>yValue</code> determines the radius that the datapoint will be plotted away from the pole of the chart.</p>

<pre><code>-(id&lt;SChartData&gt;)sChart:(ShinobiChart *)chart dataPointAtIndex:(NSInteger)dataIndex forSeriesAtIndex:(NSInteger)seriesIndex
{
    SChartDataPoint *dp = [SChartDataPoint new];

    dp.xValue = @(dataIndex);
    dp.yValue = @(dataIndex);

    return dp;
}
</code></pre></li>
</ol>


<p>The above snippets of code were taken from our <strong>PolarChart.xcodeproject</strong>.</p>

<h3>How to: Render a Radar Chart</h3>

<p>This how-to guide will lead you through the steps required in order to render a Radar Chart, a <strong>radial</strong> chart that is used to display <strong>discrete</strong> data along its <strong>x-axis</strong>.</p>

<p><em>A radial chart will render as a circular chart with two axes. The x-axis is rendered as a full circle around the outside of the charts circular plot area, the y-axis will render vertically upwards from the pole (the center) meeting the x-axis.</em></p>

<p><img src="Images/RadarChart.png"/></p>

<p>In order to render a Radar Chart you need to do the following:</p>

<ol>
<li><p>Create a chart.</p></li>
<li><p>Add an x-axis of type <code>SChartCategoryAxis</code>. To render a Radar Chart you must use an axis capable of plotting discrete data, and the only such axis that is currently supported is <code>SChartCategoryAxis</code>.</p>

<pre><code>_chart.xAxis = [SChartCategoryAxis new];
</code></pre></li>
<li><p>Add a y-axis of your choosing. (Radial Charts currently support <code>SChartNumberAxis</code> and <code>SChartCategoryAxis</code>).</p>

<pre><code>_chart.yAxis = [[SChartNumberAxis alloc] initWithRange:[[SChartNumberRange alloc] initWithMinimum:@0 andMaximum:@100]];
</code></pre></li>
<li><p>Set the <code>lineRenderMode</code> of both axes to use linear gridlines and axis lines.</p>

<pre><code>//Make X-Axis line draw as a spiderweb.
_chart.xAxis.style.majorGridLineStyle.lineRenderMode = SChartRadialLineRenderModeLinear;
//Make Y-Axis gridlines draw as a spiderweb.
_chart.yAxis.style.majorGridLineStyle.lineRenderMode = SChartRadialLineRenderModeLinear;
</code></pre></li>
<li><p>Return series of type <code>SChartRadialLineSeries</code> from your datasource via the <code>sChart:seriesAtIndex:</code> method. This causes the chart to draw in a radial fashion, with your data being plotted with a line joining your datapoints. Set the <code>pointsWrapAround</code> property to <code>YES</code> to join up the first and last points.</p>

<pre><code>-(SChartSeries *)sChart:(ShinobiChart *)chart seriesAtIndex:(NSInteger)index
{
    SChartRadialLineSeries *radialLineSeries = [SChartRadialLineSeries new];

    //Join up the first and last points
    radialLineSeries.pointsWrapAround = YES;

    return radialLineSeries;
}
</code></pre></li>
<li><p>Return <code>SChartDatapoint</code> objects from your datasource, populating the <code>xValue</code> and <code>yValue</code> properies. The <code>xValue</code> corresponds to the angle around the pole that the datapoint will be drawn at. The <code>yValue</code> determins the radius that the datapoint will be plotted away from the pole of the chart.</p>

<pre><code>-(id&lt;SChartData&gt;)sChart:(ShinobiChart *)chart dataPointAtIndex:(NSInteger)dataIndex forSeriesAtIndex:(NSInteger)seriesIndex
{
    // Set the data on the datapoint.
    SChartDataPoint *dp = [SChartDataPoint new];
    dp.xValue = _playerRatings.allKeys[dataIndex];
    dp.yValue = [_playerRatings objectForKey: dp.xValue];

    return dp;
}
</code></pre></li>
</ol>


<p>The above snippets of code were taken from our <strong>RadarChart.xcodeproject</strong>.</p>

<p><a name = "Annotations"></a></p>

<h3>How to: Add Annotations to a Chart</h3>

<p>This how-to guide will lead you through the steps required in order to add annotations to a chart.</p>

<blockquote><p><strong>NOTE:</strong> Annotations are a premium charts feature.</p></blockquote>

<p><img src="Images/Annotations.png"/></p>

<p>In order to add annotations to a chart you need to do the following:</p>

<ol>
<li>Create a chart and populate it with data, as per the Getting Started guide.</li>
<li>Add an implementation of the chart&rsquo;s delegate - <code>SChartDelegate</code>.</li>
<li>Within the <code>sChartRenderFinished:</code> method, add one or more annotations to the chart via the <code>addAnnotation:</code> method.</li>
</ol>


<p>Annotations are <code>SChartAnnotation</code> (a <code>UIView</code> subclass) instances  that are &lsquo;pinned&rsquo; to an X / Y location on the chart. As a result, the annotation will move as the users pans or zooms. You can also define annotations that are anchored at all four corners via <code>SChartAnnotationZooming</code>, as the user pans / zooms the chart the annotation will be stretched / deformed.</p>

<p>Annotations can only be added once the chart has performed an initial render. Hence, annotations should be added the first time the <code>sChartRenderFinished:</code> delegate method is called by the chart.</p>

<p><code>SChartAnnotation</code> has a number of convenience methods for creating common annotation types such as lines and text. For example, to add a text annotation you can use the following:</p>

<pre><code>// add a text annotation
SChartAnnotation *releaseLabel = [SChartAnnotation
                               annotationWithText:text
                                          andFont:[UIFont systemFontOfSize:14.f]
                                        withXAxis:_chart.xAxis
                                         andYAxis:_chart.yAxis
                                      atXPosition:date
                                     andYPosition:yValue
                                    withTextColor:[UIColor blackColor]
                                withBackgroundColor:_chart.plotAreaBackgroundColor];
[_chart addAnnotation:releaseLabel];
</code></pre>

<p>You can use any content you like as an annotation, simply create an annotation and add your content as a subview:</p>

<pre><code>// create an annotation
SChartAnnotationZooming* an = [SChartAnnotationZooming new];
an.xAxis = _chart.xAxis;
an.yAxis = _chart.yAxis;

// set its location - using the data coordinate system
an.xValue = [self dateFromString:@"01-01-2009"];
an.yValue = @250;

// pin all four corners of the annotation so that is stretches
an.xValueMax = [self dateFromString:@"01-01-2011"];
an.yValueMax = @550;

// set bounds
an.bounds = CGRectMake(0,0,50,50);
an.position = SChartAnnotationBelowData;

// Add some custom content to the annotation
UIImage* image = [UIImage imageNamed:@"Apple.png"];
UIImageView* imageView = [[UIImageView alloc] initWithImage:image];
imageView.alpha = 0.1f;
[an addSubview:imageView];

// add to the chart
[_chart addAnnotation:an];
</code></pre>

<p>Note in the above example the chart&rsquo;s X axis is a date-time axis, hence the X values for the annotation are defined as dates.</p>

<p>See related code sample: <strong>AddingAnnotations.xcodeproject</strong></p>

<p>Our tutorial <a href="http://www.shinobicontrols.com/blog/posts/2013/06/04/building-a-tornado-chart"><code>'Building a Tornado Chart'</code></a> shows how innovative use of annotations can be used to implement a Tornado Chart.</p>

<h3>How to: Handle Selection</h3>

<p>This how-to guide will lead you through the steps required in order to handle series or point selection.</p>

<p><img src="Images/HandlingSelection.png"/></p>

<p>In order to handle selection you need to do the following:</p>

<ol>
<li>Create a chart and populate it with data, as per the Getting Started guide.</li>
<li>Enable selection for one or more series by setting their <code>selectionMode</code> property to a value other than <code>SChartSelectionNone</code>.</li>
<li>Provide an implementation of the <code>SChartDelegate</code> protocol and set it as the <code>delegate</code> for the chart.</li>
<li>Implement the respective selection method, for example <code>sChart:toggledSelectionForSeries:nearPoint:atPixelCoordinate:</code>.</li>
</ol>


<p>The chart supports selection of entire series, or in the case of line and pie / donut series, the selection of individual points. You can enable selection by setting the <code>selectionMode</code> property of a series when it is requested via the datasource.</p>

<p>The chart will handle the user interaction in order to determine which series or point has been selected, with the delegate selection methods being invoked with the resulting selection state.</p>

<p>You can also set the selection state for a series programmatically by setting the <code>selected</code> property.</p>

<p>The style for a series when it is in a selected state is determined by the <code>selectedStyle</code> property.</p>

<p>See related code sample: <strong>HandlingSelection.xcodeproject</strong></p>

<p>Handling selection between two charts is demonstrated in the &lsquo;Building a Range Selector With &#83;hinobiCharts&rsquo; Parts <a href="http://www.shinobicontrols.com/blog/posts/2013/02/20/building-a-range-selector-with-shinobicharts-part-i"><code>I</code></a>, <a href="http://www.shinobicontrols.com/blog/posts/2013/03/19/building-a-range-selector-with-shinobicharts-part-ii"><code>II</code></a>, <a href="http://www.shinobicontrols.com/blog/posts/2013/04/09/building-a-range-selector-with-shinobicharts-part-iii"><code>III</code></a> and <a href="http://www.shinobicontrols.com/blog/posts/2013/05/building-a-range-selector-with-shinobicharts-part-iv"><code>IV</code></a>&lsquo;.</p>

<h3>How to: Render a Chart with Multiple Axes</h3>

<p>This how-to guide will lead you through the steps required in order to render a chart with multiple axes.</p>

<p><img src="Images/MultiAxis.png"/></p>

<p>In order to render a chart with multiple Y axes you need to do the following:</p>

<ol>
<li>Create a chart and implement the datasource methods as per the Getting Started guide.</li>
<li>Add a secondary y-axis via the <code>addYAxis</code> method. You can optionally render the secondary axis on the right-hand side of the chart by setting its <code>axisPosition</code> property to <code>SChartAxisPositionReverse</code>.</li>
<li>Implement the optional <code>sChart:yAxisForSeriesAtIndex:</code> datasource method in order to inform the chart which axis to use for each series.</li>
</ol>


<p>The chart supports multiple X and Y axes allowing you to plot data against different data value ranges. For example, you can plot two series, one representing the price of a stock (in US Dollars) and the other representing traded volume (in millions-of-trades) on the same chart by using multiple Y axes.</p>

<p>You can add multiple axes to the chart via the <code>addYAxis</code> and <code>addXAxis</code> methods:</p>

<pre><code>// add a primary y-axis
SChartNumberAxis* yAxis = [SChartNumberAxis new];
_chart.yAxis = yAxis;

// add a secondary y-axis
SChartNumberAxis* volumeAxis = [SChartNumberAxis new];
// render on the right-hand side
volumeAxis.axisPosition = SChartAxisPositionReverse;
[_chart addYAxis:volumeAxis];
</code></pre>

<p>Note that setting <code>yAxis</code> property has the same effect as adding the first axis via the <code>addYAxis</code> method. The property simply provides a convenient method for working with single axes.</p>

<p>Whilst a chart can have multiple X and Y axis, each series must be associated with a single X axis and a single Y axis. By default each series will be associated with the first X and first Y axis added to the chart. In order to specify a different axis you must implement the optional delegate methods, <code>sChart:yAxisForSeriesAtIndex:</code> or <code>sChart:xAxisForSeriesAtIndex:</code>.</p>

<p>For example, to assign each series to a unique axis, the delegate methods can be implemented as follows:</p>

<pre><code>- (`SChartAxis` *)sChart:(`ShinobiChart` *)chart yAxisForSeriesAtIndex:(NSInteger)index {
    return chart.allYAxes[index];
}
</code></pre>

<p>See related code sample: <strong>MultipleAxis.xcodeproject</strong></p>

<h3>How to: Append Data to a Chart</h3>

<p>This how-to guide will lead you through the steps required to dynamically add data to your chart, without requiring a reload of the existing data points.</p>

<p>In order to append data to a chart, you need to do the following:</p>

<ol>
<li>Provide a data source to the chart which streams new data in.</li>
<li>Notify the chart when new data points are added to the end of a chart series, and when old ones are removed from the start.</li>
<li>Tell the chart to redraw.  It will just draw the sections of the chart which have changed.</li>
</ol>


<p>To notify the chart that new data points have been added to the end of a chart series, call the <code>appendNumberOfDataPoints:toEndOfSeriesAtIndex:</code> method.  To notify the chart that data points have been removed from the start of a chart series, call the <code>removeNumberOfDataPoints:fromStartOfSeriesAtIndex:</code> method.</p>

<p>The snippet below shows how to notify the chart that a new data point has been added, and the first data point in the series has been removed:</p>

<pre><code>[self.chart removeNumberOfDataPoints:1 fromStartOfSeriesAtIndex:0];
[self.chart appendNumberOfDataPoints:1 toEndOfSeriesAtIndex:0];
[self.chart redrawChart];
</code></pre>

<p>In the next draw cycle, the chart will update to display the new data points.</p>

<p>If you would like to see a ready-made example of streaming data into a chart, take a look at the related code sample: <strong>AppendData.xcodeproj</strong>.</p>

<blockquote><p>By default, this chart will auto-calculate its axis ranges, each time it updates its data. This will effectively prevent you from panning or zooming on it. If you wish to interact with the chart, you can set the chart&rsquo;s <code>autoCalculateAxisRanges</code> property to <code>NO</code>.</p></blockquote>
				</div>

				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../../index.html">Index</a></li>
	<li><a href="../../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>

				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2015 Scott Logic Ltd. All rights reserved. (Last updated: 2015-04-29)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 858)</a>.</span></p>
						
					
					</div>
				</div>
			</div>
		</article>

		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			// Creates a table of contents item based on the name and adds it to the parent LI tag given.
			function addTocItemToLi(parentLi, itemName) {
				var disclosureSpan = document.createElement("SPAN");
				disclosureSpan.setAttribute('class', 'nodisclosure');
				parentLi.appendChild(disclosureSpan);

                var sectionNameSpan = document.createElement("SPAN");
                sectionNameSpan.setAttribute('class', 'sectionName');

                var newA = document.createElement("A");
                newA.setAttribute('href', '#'+itemName);
                newA.innerHTML = itemName;
                sectionNameSpan.appendChild(newA);

                parentLi.appendChild(sectionNameSpan);
			}
	
			// Creates a parent table of contents item given a target list and a name. Based on H2 tag.
            function addParentTocItem(targetList, itemName) {
                var newLI = document.createElement("LI");
                newLI.setAttribute('role', 'treeItem');
                newLI.setAttribute('class', 'children');
                
				addTocItemToLi(newLI, itemName);
				targetList.appendChild(newLI);

                return newLI;
            }
            
			// Creates a child table of contents item given a target list and a name. Based on H3 tag.
			function addTocChild(targetList, itemName, parent) {
				parent.firstChild.setAttribute("class", "disclosure");

				var parentUL;
				
				if(parent.getElementsByTagName("ul").length === 0) {
					parentUL = document.createElement("UL");
					parent.appendChild(parentUL);
				}
				else {
					parentUL = parent.getElementsByTagName("ul")[0];
				}
				
                var newLI = document.createElement("LI");
                
                addTocItemToLi(newLI, itemName);
                                
               	parentUL.appendChild(newLI);
    		}

			// Finds all tags specified in the tag_names array in the root element.
			function findTags(root) {
				if( root.nodeType === 1 && root.nodeName !== 'script' ) {
				
					if( tag_names.hasOwnProperty(root.nodeName.toLowerCase()) ) {
						headings.push( root );
					} 
					else {
						for( var i = 0; i < root.childNodes.length; i++ ) {
							findTags(root.childNodes[i]);
						}
					}
				}
			}
			
			// Adds click listeners to every link in the table of contents.
			function setupTocClicks () {
				var tocList = document.getElementById('toc');

				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
			}
			
			var headings = [];
			var tag_names = {
                    h1:1,
    				h2:1,
    				h3:1,
				};
			
			
			function init() {
				findTags(document.body);
				
				var lastH2;
				for( var i = 0; i < headings.length; i++ ) {
   					var hName = headings[i].innerHTML;
   					
   					var newA = document.createElement("A");
					newA.setAttribute('name', hName);
					headings[i].parentNode.insertBefore(newA, headings[i]);
   					
   					if(headings[i].nodeName.toLowerCase() === "h1") {
                        if (headings[i].id.toLowerCase() != "pagetitleheader" &&
                            (headings[i].className == undefined || headings[i].className != "title title-header")) {
   					   	   lastH2 = addParentTocItem(document.getElementById("toc"), hName);
                        }
   					}
   					else if (lastH2 && headings[i].nodeName.toLowerCase() === "h2") {
   						addTocChild(document.getElementById("toc"), hName, lastH2);
   					}
				}
				
				setupTocClicks();
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>


	</body>
</html>